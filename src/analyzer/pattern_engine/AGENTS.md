# Pattern Engine Documentation

**Parent Instructions**: See `/AGENTS.md` for global project context and universal coding guidelines.

**This document** contains pattern engine-specific implementation details that extend/override root instructions.

---

## Overview

- **Chart Pattern Engine** (`pattern_engine.py`) scans OHLCV arrays for classical swing-based formations (head and shoulders, triangles, wedges, channels, multiple tops/bottoms) and labels raw swing points. All detection is vectorized NumPy with numba acceleration.
- **Indicator Pattern Engine** (`indicator_patterns/indicator_pattern_engine.py`) consumes the `technical_history` map generated by `TechnicalCalculator` plus optional OHLCV/long-term SMA context, returning structured momentum, divergence, volatility, stochastic, moving-average, and volume signals.
- `PatternAnalyzer` (`src/analyzer/calculations/pattern_analyzer.py`) calls both engines, merges their results, and injects the combined payload into prompts, HTML, and Discord embeds.

## Directory Layout

- `pattern_engine.py`: Chart pattern orchestrator (`PatternEngine`).
- `swing_detection.py`: Swing high/low detection and classification helpers (HH, LH, HL, LL).
- `pattern_matchers.py`: numba matchers for individual chart structures (head/shoulders, triangles, wedges, channels, multi-top/bottom).
- `trendline_fitting.py`: Regression utilities used by the channel/wedge detectors to confirm slope alignment.
- `indicator_patterns/`: Indicator-specific detectors and the `IndicatorPatternEngine` orchestrator.
    - `indicator_pattern_engine.py`: Orchestrator
    - `divergence_patterns.py`: Divergence detection
    - `ma_crossover_patterns.py`: Moving average crossovers
    - `macd_patterns.py`: MACD patterns
    - `rsi_patterns.py`: RSI patterns
    - `stochastic_patterns.py`: Stochastic patterns
    - `volatility_patterns.py`: Volatility patterns
    - `volume_patterns.py`: Volume patterns

## Chart Pattern Engine

### PatternEngine

```python
engine = PatternEngine(lookback=7, lookahead=7, format_utils=format_utils)
patterns = engine.detect_patterns(ohlcv_array, timestamps)
```

- **Inputs**: NumPy OHLCV array (`[:,1]` high, `[:,2]` low, `[:,3]` close) and optional parallel `timestamps` list.
- **Swing Scan**: `detect_swing_highs_numba` / `detect_swing_lows_numba` mark pivots using the configured lookback/lookahead windows (default 7). Provide at least `lookback + lookahead` candles; otherwise detection returns `{}`.
- **Pattern Matching**: Each matcher receives the swing masks and returns an `int32` array labeling the candle index where the structure completes. Pattern codes:
	- `head_shoulder`: `1` head and shoulder, `2` inverse head and shoulder.
	- `double_top_bottom`: `1` double top, `2` double bottom.
	- `triangle`: `1` descending triangle, `2` ascending triangle.
	- `wedge`: `1` rising wedge, `2` falling wedge.
	- `channel`: `1` channel up, `2` channel down (parallel trendlines confirmed via `trendline_fitting.parallel_trendlines_numba`).
	- `multiple_tops_bottoms`: `1` multi-top cluster, `2` multi-bottom cluster.
	- `swing_points`: `1` higher high, `2` lower high, `3` higher low, `4` lower low (from `classify_swings_numba`).
- **Output Shape**: Dictionary mapping category → list of pattern dicts:

```json
{
	"head_shoulder": [
		{
			"type": "Head and Shoulder",
			"index": 183,
			"description": "Head and Shoulder at 2025-11-02 04:00:00 (index 183)",
			"details": {"pattern_code": 1},
			"timestamp": "2025-11-02T04:00:00"
		}
	],
	"swing_points": [...]
}
```
- **Timestamp Handling**: When `timestamps` is provided, `_extract_patterns` formats the human-readable description and stores the raw timestamp. If a timestamp entry is not datetime-like it falls back to string formatting via `format_utils`.
- **Smoothing Option**: `detect_swings_smoothed` applies the `f_ess` filter before swing detection. Use when high-volatility noise generates spurious pivots.

### Configuration Notes

- Tune `lookback`/`lookahead` per timeframe. Shorter windows (3–4) increase sensitivity; longer windows reduce noise but may miss compact structures.
- Ensure `ohlcv` includes the current candle. Pattern detection expects the latest data point to reflect the most recent swing classification.
- The engine deliberately omits confidence scoring; downstream components (prompts, HTML) rely on pattern type and recentness for weighting.

## Indicator Pattern Engine

### Orchestrator Workflow

```python
indicator_patterns = IndicatorPatternEngine(logger, format_utils)
signals = indicator_patterns.detect_patterns(
		technical_history,
		ohlcv_data=context.ohlcv_candles,
		long_term_sma_values=context.indicators.get("long_term_sma"),
		timestamps=context.timestamps
)
```

- **Required Inputs**: `technical_history` must contain NumPy arrays keyed by indicator name (e.g., `rsi`, `macd_line`, `macd_signal`, `stoch_k`, `atr`, `bb_upper`, `bb_lower`, `kc_upper`, `kc_lower`). Arrays are expected to be aligned and ordered oldest → newest.
- **Optional Inputs**: `ohlcv_data` (for divergences and volume work), `long_term_sma_values` (precomputed 20/50/200 SMA values), and `timestamps` (for human-readable descriptions).
- **Return Value**: Dictionary with seven categories: `rsi`, `macd`, `divergence`, `volatility`, `stochastic`, `ma_crossover`, `volume`. Each category is a list of pattern dicts describing type, index, description, and relevant metadata (thresholds, periods ago, indicator values).
- **Timing Labels**: `_format_pattern_time` converts `periods_ago` counters into strings such as “now”, “1 period ago”, or “4 periods ago at 2025-10-30 12:00:00”.
- **Error Handling**: Missing keys simply yield empty lists; no defensive type checks are performed per project guidelines.

### Indicator Pattern Catalog

#### RSI Patterns

- **`detect_rsi_oversold_numba`**: Signals RSI < 30. Returns `(is_oversold, periods_ago, rsi_value)`.
- **`detect_rsi_overbought_numba`**: Signals RSI > 70. Returns `(is_overbought, periods_ago, rsi_value)`.
- **`detect_rsi_w_bottom_numba`**: Confirms bullish double-bottom structure when RSI improves while price retests lows.
- **`detect_rsi_m_top_numba`**: Confirms bearish double-top when RSI weakens on higher price highs.

#### MACD Patterns

- **`detect_macd_crossover_numba`**: Detects the most recent MACD/signal crossover and classifies bullish vs bearish.
- **`detect_macd_zero_cross_numba`**: Flags MACD crossing the zero line, often signaling macro momentum shifts.
- **`get_macd_histogram_trend_numba`**: Returns histogram slope (+1 increasing, -1 decreasing) for acceleration cues.

#### Divergence Patterns

- **`detect_bullish_divergence_numba`**: Price makes lower lows while the indicator makes higher lows.
- **`detect_bearish_divergence_numba`**: Price makes higher highs while the indicator makes lower highs.

#### Volatility Patterns

- **`detect_atr_spike_numba`**: Highlights ATR surges relative to recent history.
- **`detect_bb_squeeze_numba`**: Bollinger Band width collapses into the lowest percentile.
- **`detect_volatility_trend_numba`**: Classifies volatility regime (rising, falling, stable).
- **`detect_keltner_squeeze_numba`**: TTM Squeeze condition, Bollinger Bands entirely inside Keltner Channels.

#### Moving Average Crossover Patterns

- **`detect_golden_cross_numba`**: 50 SMA crossing above 200 SMA.
- **`detect_death_cross_numba`**: 50 SMA crossing below 200 SMA.
- **`detect_short_term_crossover_numba`**: 20 SMA vs 50 SMA crossover.
- **`check_ma_alignment_numba`**: Trend alignment check (20 > 50 > 200 bullish, inverse bearish).

#### Stochastic Patterns

- **`detect_stoch_oversold_numba`**: %K below 20.
- **`detect_stoch_overbought_numba`**: %K above 80.
- **`detect_stoch_bullish_crossover_numba`**: %K crossing above %D in oversold zone.
- **`detect_stoch_bearish_crossover_numba`**: %K crossing below %D in overbought zone.
- **`detect_stoch_divergence_numba`**: Divergence logic similar to RSI/MACD but on stochastic oscillator.

#### Volume Patterns

- **`detect_volume_spike_numba`**: Volume exceeding a configurable multiple of average volume.
- **`detect_volume_dryup_numba`**: Volume compression relative to average.
- **`detect_volume_price_divergence_numba`**: Price advancing/declining against weakening volume.
- **`detect_accumulation_distribution_numba`**: Bias toward accumulation (buy pressure) or distribution (sell pressure) based on volume/price interplay.
- **`detect_climax_volume_numba`**: Extreme volume spikes (default 3x average) often marking exhaustion moves.

### Implementation Notes

- All indicator detectors are `@njit(cache=True)` for low-latency evaluation across 500–1,000-candle arrays.
- Functions expect arrays with the most recent value at index `-1`. `IndicatorPatternEngine` automatically aligns indices with OHLCV timestamps when available.
- Each detector returns simple tuples; the orchestrator converts them into uniform dictionaries for downstream formatting.

## Integration with Analysis

- `PatternAnalyzer.analyze_patterns(context)` runs both engines, stores `context.patterns`, and forwards pattern lists to the prompt builder and HTML generator.
- Chart patterns feed chart annotations and prompt narrative (“Head and Shoulder detected 4h ago”).
- Indicator patterns add confirmation signals, risk warnings, and follow-up questions in Discord embeds.
- No state is persisted between runs; each invocation recalculates patterns from scratch to reflect the latest candle (including the incomplete current candle to stay real-time).

## Troubleshooting & Tips

- **Empty Results**: Confirm `ohlcv` length exceeds `lookback + lookahead` and that `technical_history` keys exist. Missing data yields empty lists without raising errors.
- **Too Noisy**: Increase `lookback`/`lookahead` or use `detect_swings_smoothed` with a longer `smooth_length` to reduce false positives on lower timeframes.
- **Mismatched Lengths**: Ensure indicator arrays share the same length as `ohlcv`. Divergence and volume detectors skip processing if lengths differ.
- **Performance**: Both engines operate in microseconds once numba JIT caches are warm. The heaviest operations are the initial JIT compile; keep the bot warm during deployment to avoid first-run latency.

---

## Summary Documents Policy

**Do not create summary documents** in `.md` format or any format. All documentation should be maintained in the appropriate `AGENTS.md` file.